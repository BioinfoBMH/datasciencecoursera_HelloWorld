5+5
print("Tavia")
mean(mtcars$mpg)
q()
# maternal_logistic.R
library(tidyverse)
library(pROC)
library(broom)
df <- read_csv("maternal_data.csv")
df <- read_csv("C:\Users\tavia\Documents\BioinfoBMH\maternal_data.csv")
df <- read_csv("C:/Users/tavia/Documents/BioinfoBMH/maternal_data.csv")
spec()
View(df)
df <- df %>%
mutate(
delivery_cs = if_else(delivery_mode == "CS", 1, 0), #The delivery mode column is paired with a code in the newly added deliver_cs column
region = factor(region), #The factor function converts strings to factors or categorical values
outcome = as.integer(outcome)
) %>%
# maternal_logistic.R
library(tidyverse)
# maternal_logistic.R
library(tidyverse)
library(pROC)
library(broom)
df <- read_csv("C:/Users/tavia/Documents/BioinfoBMH/maternal_data.csv")
df <- df %>%
mutate(
delivery_cs = if_else(delivery_mode == "CS", 1, 0), #The delivery mode column is paired with a code in the newly added deliver_cs column
region = factor(region), #The factor function converts strings to factors or categorical values
outcome = as.integer(outcome)
)
df <- mutate(
df,
delivery_cs = if_else(delivery_mode == "CS", 1, 0), #The delivery mode column is paired with a code in the newly added deliver_cs column
region = factor(region), #The factor function converts strings to factors or categorical values
outcome = as.integer(outcome)
)
library(tidyverse)
library(pROC)
library(broom)
df <- read_csv("C:/Users/tavia/Documents/BioinfoBMH/maternal_data.csv")
df <- mutate(
df,
delivery_cs = if_else(delivery_mode == "CS", 1, 0), #The delivery mode column is paired with a code in the newly added deliver_cs column
region = factor(region), #The factor function converts strings to factors or categorical values
outcome = as.integer(outcome)
)
df <- drop_na(age, parity, gest_weeks, prenatal_visits, hb_level, socioeconomic_index)
# Run this function, and it will prompt you to type in analytes and values.
plot_average_ecl_from_input()
# ---------------- Example Usage ----------------
# Run this function and it will prompt for input interactively
plot_average_ecl_from_input()
plot_average_ecl_from_input <- function() {
# This function asks the user to type in analyte names and their three ECL values.
# It calculates the average ECL signal for each analyte and returns a bar graph.
#
# The user can keep adding analytes until they type 'done'.
# If no analytes are entered, the function returns NULL.
analytes <- c()   # Vector to store analyte names
averages <- c()   # Vector to store average ECL values
cat("Enter analyte names and their 3 ECL values.\n")
cat("Type 'done' when you are finished.\n\n")
while (TRUE) {
# Step 1: Ask for the analyte name
analyte <- readline(prompt = "Enter analyte name (or type 'done' to finish): ")
# Step 2: Exit condition
if (tolower(analyte) == "done") {
break
}
# Step 3: Ask for three ECL values
# We use as.numeric() to make sure input is stored as numbers
ecl1 <- as.numeric(readline(prompt = paste("Enter first ECL value for", analyte, ": ")))
ecl2 <- as.numeric(readline(prompt = paste("Enter second ECL value for", analyte, ": ")))
ecl3 <- as.numeric(readline(prompt = paste("Enter third ECL value for", analyte, ": ")))
# Handle invalid (non-numeric) input
if (any(is.na(c(ecl1, ecl2, ecl3)))) {
cat("❌ Invalid input! Please enter numeric values for ECL signals.\n\n")
next
}
# Step 4: Calculate the average
avg <- mean(c(ecl1, ecl2, ecl3))
# Step 5: Save the results
analytes <- c(analytes, analyte)
averages <- c(averages, avg)
cat(paste("✅ Added", analyte, "with average ECL", round(avg, 2), "\n\n"))
}
# Step 6: Handle case when no analytes were entered
if (length(analytes) == 0) {
cat("No analytes entered. Returning NULL.\n")
return(NULL)
}
# Step 7: Plot the results
bar_positions <- barplot(
averages,
names.arg = analytes,
col = "orange",
border = "black",
main = "Analyte vs. Average ECL Signal",
xlab = "Analytes",
ylab = "Average ECL Signal",
las = 2  # Rotate labels if they are long
)
# Add average values on top of bars
text(bar_positions, averages + 1, labels = round(averages, 1), cex = 0.8)
return(TRUE)
}
plot_average_ecl_from_input <- function() {
# This function asks the user to type in analyte names and their three ECL values.
# It calculates the average ECL signal for each analyte and returns a bar graph.
#
# The user can keep adding analytes until they type 'done'.
# If no analytes are entered, the function returns NULL.
analytes <- c()   # Vector to store analyte names
averages <- c()   # Vector to store average ECL values
cat("Enter analyte names and their 3 ECL values.\n")
cat("Type 'done' when you are finished.\n\n")
while (TRUE) {
# Step 1: Ask for the analyte name
analyte <- readline(prompt = "Enter analyte name (or type 'done' to finish): ")
# Step 2: Exit condition
if (tolower(analyte) == "done") {
break
}
# Step 3: Ask for three ECL values
# We use as.numeric() to make sure input is stored as numbers
ecl1 <- as.numeric(readline(prompt = paste("Enter first ECL value for", analyte, ": ")))
ecl2 <- as.numeric(readline(prompt = paste("Enter second ECL value for", analyte, ": ")))
ecl3 <- as.numeric(readline(prompt = paste("Enter third ECL value for", analyte, ": ")))
# Handle invalid (non-numeric) input
if (any(is.na(c(ecl1, ecl2, ecl3)))) {
cat("❌ Invalid input! Please enter numeric values for ECL signals.\n\n")
next
}
# Step 4: Calculate the average
avg <- mean(c(ecl1, ecl2, ecl3))
# Step 5: Save the results
analytes <- c(analytes, analyte)
averages <- c(averages, avg)
cat(paste("✅ Added", analyte, "with average ECL", round(avg, 2), "\n\n"))
}
# Step 6: Handle case when no analytes were entered
if (length(analytes) == 0) {
cat("No analytes entered. Returning NULL.\n")
return(NULL)
}
# Step 7: Plot the results
bar_positions <- barplot(
averages,
names.arg = analytes,
col = "orange",
border = "black",
main = "Analyte vs. Average ECL Signal",
xlab = "Analytes",
ylab = "Average ECL Signal",
las = 2  # Rotate labels if they are long
)
# Add average values on top of bars
text(bar_positions, averages + 1, labels = round(averages, 1), cex = 0.8)
return(TRUE)
}
plot_average_ecl_from_input <- function() {
# This function asks the user to type in analyte names and their three ECL values.
# It calculates the average ECL signal for each analyte and returns a bar graph.
#
# The user can keep adding analytes until they type 'done'.
# If no analytes are entered, the function returns NULL.
analytes <- c()   # Vector to store analyte names
averages <- c()   # Vector to store average ECL values
cat("Enter analyte names and their 3 ECL values.\n")
cat("Type 'done' when you are finished.\n\n")
while (TRUE) {
# Step 1: Ask for the analyte name
analyte <- readline(prompt = "Enter analyte name (or type 'done' to finish): ")
# Step 2: Exit condition
if (tolower(analyte) == "done") {
break
}
# Step 3: Ask for three ECL values
# We use as.numeric() to make sure input is stored as numbers
ecl1 <- as.numeric(readline(prompt = paste("Enter first ECL value for", analyte, ": ")))
ecl2 <- as.numeric(readline(prompt = paste("Enter second ECL value for", analyte, ": ")))
ecl3 <- as.numeric(readline(prompt = paste("Enter third ECL value for", analyte, ": ")))
# Handle invalid (non-numeric) input
if (any(is.na(c(ecl1, ecl2, ecl3)))) {
cat("❌ Invalid input! Please enter numeric values for ECL signals.\n\n")
next
}
# Step 4: Calculate the average
avg <- mean(c(ecl1, ecl2, ecl3))
# Step 5: Save the results
analytes <- c(analytes, analyte)
averages <- c(averages, avg)
cat(paste("✅ Added", analyte, "with average ECL", round(avg, 2), "\n\n"))
}
# Step 6: Handle case when no analytes were entered
if (length(analytes) == 0) {
cat("No analytes entered. Returning NULL.\n")
return(NULL)
}
# Step 7: Plot the results
bar_positions <- barplot(
averages,
names.arg = analytes,
col = "orange",
border = "black",
main = "Analyte vs. Average ECL Signal",
xlab = "Analytes",
ylab = "Average ECL Signal",
las = 2  # Rotate labels if they are long
)
# Add average values on top of bars
text(bar_positions, averages + 1, labels = round(averages, 1), cex = 0.8)
return(TRUE)
}
plot_average_ecl_from_input <- function() {
# This function asks the user to type in analyte names and their three ECL values.
# It calculates the average ECL signal for each analyte and returns a bar graph.
#
# The user can keep adding analytes until they type 'done'.
# If no analytes are entered, the function returns NULL.
analytes <- c()   # Vector to store analyte names
averages <- c()   # Vector to store average ECL values
cat("Enter analyte names and their 3 ECL values.\n")
cat("Type 'done' when you are finished.\n\n")
while (TRUE) {
# Step 1: Ask for the analyte name
analyte <- readline(prompt = "Enter analyte name (or type 'done' to finish): ")
# Step 2: Exit condition
if (tolower(analyte) == "done") {
break
}
# Step 3: Ask for three ECL values
# We use as.numeric() to make sure input is stored as numbers
ecl1 <- as.numeric(readline(prompt = paste("Enter first ECL value for", analyte, ": ")))
ecl2 <- as.numeric(readline(prompt = paste("Enter second ECL value for", analyte, ": ")))
ecl3 <- as.numeric(readline(prompt = paste("Enter third ECL value for", analyte, ": ")))
# Handle invalid (non-numeric) input
if (any(is.na(c(ecl1, ecl2, ecl3)))) {
cat("❌ Invalid input! Please enter numeric values for ECL signals.\n\n")
next
}
# Step 4: Calculate the average
avg <- mean(c(ecl1, ecl2, ecl3))
# Step 5: Save the results
analytes <- c(analytes, analyte)
averages <- c(averages, avg)
cat(paste("✅ Added", analyte, "with average ECL", round(avg, 2), "\n\n"))
}
# Step 6: Handle case when no analytes were entered
if (length(analytes) == 0) {
cat("No analytes entered. Returning NULL.\n")
return(NULL)
}
# Step 7: Plot the results
bar_positions <- barplot(
averages,
names.arg = analytes,
col = "maroon",
border = "black",
main = "Analyte vs. Average ECL Signal",
xlab = "Analytes",
ylab = "Average ECL Signal",
las = 2  # Rotate labels if they are long
)
# Add average values on top of bars
text(bar_positions, averages + 1, labels = round(averages, 1), cex = 0.8)
return(TRUE)
}
plot_average_ecl_from_input()
install.packages("rmarkdown")
knitr::opts_chunk$set(echo = TRUE)
print("Hello World")
# ============================================
# Generic Excel → SQLite Wardrobe Importer
# ============================================
library(readxl)
library(DBI)
library(RSQLite)
library(dplyr)
library(stringr)
library(lubridate)
# ---- YOUR PATHS (EDIT THESE ONLY) ----
excel_path <- "C:/path/to/your/wardrobe.xlsx"
db_path    <- "C:/Users/tavia/Documents/Data Science/WardrobeApp/wardrobe.sqlite"
# ---- Read Excel File ----
raw <- read_excel(excel_path)
library(shiny); runApp('Data Science/WardrobeTracker.R')
runApp('Data Science/wardrobe app.R')
runApp('Data Science/WardrobeTracker.R')
# ============================================
# Wardrobe Excel → SQLite Inventory Importer
# (Extended from your Business Importer Script)
# ============================================
library(readxl)
library(DBI)
library(RSQLite)
library(dplyr)
library(stringr)
# ---- YOUR PATHS (EDIT THESE ONLY) ----
excel_path <- "C:/path/to/wardrobe.xlsx"
db_path    <- "C:/Users/tavia/Documents/Data Science/WardrobeApp/wardrobe.sqlite"
# ---- Read Excel File ----
raw <- read_excel(excel_path)
# ============================================
# Create an EMPTY wardrobe table (no Excel needed)
# ============================================
library(DBI)
library(RSQLite)
db_path <- "C:/Users/tavia/Documents/Data Science/WardrobeApp/wardrobe.sqlite"
conn <- dbConnect(SQLite(), db_path)
# ============================================
# Create an EMPTY wardrobe table (no Excel needed)
# ============================================
library(DBI)
library(RSQLite)
db_path <- "C:/Users/tavia/Documents/Data Science/WardrobeApp/wardrobe.sqlite"
conn <- dbConnect(SQLite(), db_path)
# ============================================
# Create EMPTY wardrobe.sqlite from scratch
# ============================================
library(DBI)
library(RSQLite)
# ---- Where to create your SQLite file ----
db_path <- "C:/Users/tavia/Documents/Data Science/WardrobeApp/wardrobe.sqlite"
# Create folder if missing
dir.create(dirname(db_path), showWarnings = FALSE, recursive = TRUE)
# Connect to database (creates file if missing)
conn <- dbConnect(SQLite(), db_path)
# ---- Create empty wardrobe table ----
dbExecute(conn, "
CREATE TABLE IF NOT EXISTS wardrobe (
ItemKey        TEXT PRIMARY KEY,
Person         TEXT,
Location       TEXT,
Category       TEXT,
Type           TEXT,
Season         TEXT,
Color          TEXT,
Size           TEXT,
Brand          TEXT,
Condition      TEXT,
Quantity       INTEGER,
PurchaseDate   TEXT,
Price          REAL,
LastWorn       TEXT,
Notes          TEXT,
PhotoPath      TEXT
);
")
dbDisconnect(conn)
cat('✔ wardrobe.sqlite created successfully!\n')
cat('✔ Location:', db_path, '\n')
cat('✔ Table: wardrobe (empty, ready for Shiny app)\n')
# ============================================
# Create an EMPTY wardrobe table (no Excel needed)
# ============================================
library(DBI)
library(RSQLite)
db_path <- "C:/Users/tavia/Documents/Data Science/WardrobeApp/wardrobe.sqlite"
conn <- dbConnect(SQLite(), db_path)
dbExecute(conn, "
CREATE TABLE IF NOT EXISTS wardrobe (
ItemKey      TEXT PRIMARY KEY,
Person       TEXT,
Location     TEXT,
Category     TEXT,
Type         TEXT,
Season       TEXT,
PrimaryColor TEXT,
SecondaryColor TEXT,
Size         TEXT,
Brand        TEXT,
Condition    TEXT,
FitStatus    TEXT,
Notes        TEXT,
PhotoPath    TEXT,
PurchaseDate TEXT,
Price        REAL,
LastWorn     TEXT,
Quantity     INTEGER
);
")
dbDisconnect(conn)
cat('✔ Empty wardrobe database created.\n')
runApp('Data Science/WardrobeTracker.R')
runApp('Data Science/WardrobeTracker.R')
install.packages("rmarkdown")
# knitr::opts_chunk$set(echo = TRUE)
```{r # setup, include=FALSE} <br>
---
title: "HelloWorld"
---
title: "HelloWorld"
---
title: "HelloWorld"
![HelloWorld Screenshot](hello_screenshot.png)
setwd("C:/Users/tavia/Documents/Data Science/Assemble Your Toolbox")
getwd()
usethis::use_git_remote(
name = "origin",
url = "git@github.com:BioinfoBMH/datasciencecoursera.git"
)
install.packages("gert")
usethis::use_git_remote(
name = "origin",
url = "git@github.com:BioinfoBMH/datasciencecoursera.git"
)
library(gert)
